<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Card Duel ‚Äî Fixed (‡πÑ‡∏ó‡∏¢)</title>
<style>
  :root{--bg:#071226;--card:#0b3740;--accent:#ffd166;--good:#6ee7b7;--danger:#ff6b6b;--muted:#9fb3c8}
  *{box-sizing:border-box}
  body{margin:0;font-family:Inter,Segoe UI,Arial;background:linear-gradient(180deg,#04121a,#021018);color:#eaf6f3;display:flex;align-items:center;justify-content:center;padding:16px}
  .wrap{width:1000px;max-width:98vw;border-radius:12px;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(0,0,0,0.06));}
  h1{margin:0 0 8px 0;font-size:18px}
  .top{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .btn{background:#0f3b39;border:0;padding:8px 12px;border-radius:8px;color:#fff;cursor:pointer}
  .layout{display:flex;gap:12px}
  .left{flex:1}
  .board{background:linear-gradient(180deg,#061924,#021219);padding:10px;border-radius:8px;display:grid;grid-template-columns:repeat(7,1fr);grid-auto-rows:90px;gap:8px}
  .cell{background:rgba(255,255,255,0.02);border-radius:8px;display:flex;align-items:center;justify-content:center;position:relative;cursor:pointer;transition:transform .12s}
  .cell:hover{transform:translateY(-6px)}
  .unit{width:92%;height:88%;border-radius:8px;background:linear-gradient(180deg,#0b2f36,#041b1f);display:flex;flex-direction:column;align-items:center;justify-content:center;padding:6px}
  .right{width:320px}
  .panel{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;margin-bottom:8px}
  .hand{display:flex;gap:8px;flex-wrap:wrap}
  .card{width:100px;height:140px;border-radius:8px;background:linear-gradient(180deg,var(--card),#041b1f);padding:8px;color:#eaf6f3;cursor:pointer;display:flex;flex-direction:column;justify-content:space-between;align-items:center}
  .card.disabled{opacity:.45;cursor:not-allowed}
  .art{font-size:32px}
  .log{height:160px;overflow:auto;padding:6px;border-radius:6px;background:rgba(0,0,0,0.12)}
  .hud{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  .hpbar{height:12px;background:rgba(255,255,255,0.04);border-radius:8px;overflow:hidden;width:220px}
  .hpfill{height:100%;background:linear-gradient(90deg,#6ee7b7,#95f7d0);width:100%;transition:width .4s}
  .hpfill.enemy{background:linear-gradient(90deg,#ff8b8b,#ffcfb3)}
  .tooltip{position:fixed;padding:8px 10px;background:#061924;border-radius:8px;color:var(--accent);font-size:13px;pointer-events:none;opacity:0;transform:translateY(6px);transition:opacity .12s,transform .12s;z-index:9999}
  .modal{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.6);opacity:0;pointer-events:none;transition:opacity .12s}
  .modal.show{opacity:1;pointer-events:auto}
  .modal .box{background:#042631;padding:16px;border-radius:10px;color:#eaf6f3}
  @media(max-width:900px){ .layout{flex-direction:column}.right{width:100%} }
</style>
</head>
<body>
<div class="wrap">
  <div class="top">
    <h1>Card Duel ‚Äî Fixed (‡πÑ‡∏ó‡∏¢)</h1>
    <div>
      <button class="btn" id="btnNew">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÉ‡∏´‡∏°‡πà</button>
      <button class="btn" id="btnHint">‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô</button>
    </div>
  </div>

  <div class="hud">
    <div>
      <div style="font-size:13px">‡∏ú‡∏π‡πâ‡πÄ‡∏•‡πà‡∏ô <span id="playerHP">36</span> HP</div>
      <div class="hpbar" style="margin-top:6px"><div id="playerFill" class="hpfill"></div></div>
    </div>
    <div>
      <div style="font-size:13px">‡∏®‡∏±‡∏ï‡∏£‡∏π <span id="enemyHP">28</span> HP</div>
      <div class="hpbar" style="margin-top:6px;width:180px"><div id="enemyFill" class="hpfill enemy"></div></div>
    </div>
    <div>
      <div style="font-size:13px">Mana: <span id="mana">6</span>/<span id="maxMana">6</span></div>
      <div style="font-size:12px;color:var(--muted)">‡∏™‡∏≥‡∏£‡∏±‡∏ö: <span id="deckCount">0</span></div>
    </div>
  </div>

  <div class="layout">
    <div class="left">
      <div id="board" class="board" aria-hidden="false"></div>
      <div style="display:flex;gap:8px;justify-content:center;margin-top:10px">
        <button class="btn" id="btnDraw">‡∏à‡∏±‡πà‡∏ß</button>
        <button class="btn" id="btnEnd">‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</button>
      </div>
    </div>

    <div class="right">
      <div class="panel">
        <div style="font-size:13px">‡∏°‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì</div>
        <div id="playerHand" class="hand" style="margin-top:8px"></div>
      </div>

      <div class="panel">
        <div style="font-size:13px">‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô‡∏®‡∏±‡∏ï‡∏£‡∏π (‡∏°‡∏∏‡∏°‡∏°‡∏≠‡∏á)</div>
        <div id="enemyZone" class="hand" style="margin-top:8px"></div>
      </div>

      <div class="panel">
        <div style="font-size:13px">‡πÄ‡∏´‡∏ï‡∏∏‡∏Å‡∏≤‡∏£‡∏ì‡πå</div>
        <div id="log" class="log"></div>
      </div>
    </div>
  </div>
</div>

<div id="tooltip" class="tooltip"></div>
<div id="modal" class="modal"><div class="box" id="modalBox"></div></div>

<script>
/* Stable single-file Card Duel ‚Äî Fixed
 - simpler, robust variable names
 - drag & drop + click-to-play
 - AI: draw 1 / play max 1 per turn (easy)
 - mana: player start 6 +2 per turn (cap 14), AI start 4 +1 (cap 10)
*/

// --- Config & State ---
const ROWS = 5, COLS = 7, CELLS = ROWS * COLS;

let deck = [];
let playerHand = [];
let playerUnits = Array(CELLS).fill(null);
let enemyUnits = Array(CELLS).fill(null);

let playerHP = 36, enemyHP = 28;
let mana = 6, maxMana = 6;
let aiMana = 4, aiMaxMana = 4;

let enemyHand = [];
let selectedHandIndex = null; // for click-to-play
let dragIndex = null;

let stats = { wins:0, losses:0, games:0 };

// --- Elements ---
const boardEl = document.getElementById('board');
const playerHandEl = document.getElementById('playerHand');
const enemyZoneEl = document.getElementById('enemyZone');
const logEl = document.getElementById('log');
const tooltip = document.getElementById('tooltip');
const modal = document.getElementById('modal');
const modalBox = document.getElementById('modalBox');

// --- Utility ---
function randId(){ return Math.random().toString(36).slice(2,9); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }
function addLog(text, who='info'){ const d = document.createElement('div'); d.innerHTML = (who==='player'?`<span style="color:#6ee7b7">`:`<span style="color:#ff8b8b">`) + text + '</span>'; logEl.prepend(d); }
function showTooltip(e, text){ tooltip.style.opacity=1; tooltip.textContent=text; tooltip.style.left=(e.clientX+12)+'px'; tooltip.style.top=(e.clientY+12)+'px'; tooltip.style.transform='translateY(0)'; }
function moveTooltip(e){ tooltip.style.left=(e.clientX+12)+'px'; tooltip.style.top=(e.clientY+12)+'px'; }
function hideTooltip(){ tooltip.style.opacity=0; tooltip.style.transform='translateY(6px)'; }
function showModal(title, content){ modalBox.innerHTML = `<h3>${title}</h3><div style="margin-top:8px">${content}</div><div style="margin-top:12px"><button class="btn" onclick="hideModal()">‡∏õ‡∏¥‡∏î</button></div>`; modal.classList.add('show'); }
function hideModal(){ modal.classList.remove('show'); }

// --- Audio (optional, safe) ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
const audioCtx = AudioCtx ? new AudioCtx() : null;
function playTone(type){
  if(!audioCtx) return;
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(type==='draw'){ o.type='sine'; o.frequency.setValueAtTime(880,now); g.gain.setValueAtTime(0.02, now); o.start(now); o.stop(now+0.06); }
    if(type==='attack'){ o.type='square'; o.frequency.setValueAtTime(220,now); g.gain.setValueAtTime(0.03, now); o.start(now); o.stop(now+0.09); }
    if(type==='heal'){ o.type='sine'; o.frequency.setValueAtTime(660,now); g.gain.setValueAtTime(0.025, now); o.start(now); o.stop(now+0.12); }
  }catch(e){ /* ignore audio errors */ }
}

// --- Cards ---
function makeCard(name, atk, hp, cost, effect, icon){
  return { id: randId(), name, atk, hp, cost, effect: effect||null, icon: icon||'‚öîÔ∏è', sleep:1, poison:0, shield:0 };
}
function buildDeck(){
  const base = [
    makeCard('‡∏ô‡∏±‡∏Å‡∏£‡∏ö',4,3,2,null,'üó°Ô∏è'),
    makeCard('‡∏ô‡∏±‡∏Å‡∏ò‡∏ô‡∏π',3,2,1,{type:'double',value:1},'üèπ'),
    makeCard('‡∏ú‡∏π‡πâ‡∏û‡∏¥‡∏ó‡∏±‡∏Å‡∏©‡πå',1,6,3,{type:'shield',value:3},'üõ°Ô∏è'),
    makeCard('‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏Å‡∏©‡∏≤',0,4,2,{type:'heal',value:5},'üíö'),
    makeCard('‡∏û‡∏¥‡∏©',2,2,2,{type:'poison',value:2},'‚ò†Ô∏è'),
    makeCard('‡∏û‡πà‡∏≠‡∏°‡∏î',3,1,2,{type:'aoe',value:2},'üîÆ'),
    makeCard('‡∏≠‡∏±‡∏®‡∏ß‡∏¥‡∏ô',5,6,5,null,'üèá'),
    makeCard('‡∏ô‡πâ‡∏≥‡∏û‡∏∏‡∏û‡∏•‡∏±‡∏á',0,0,0,{type:'mana',value:3},'üîã')
  ];
  deck = [];
  for(let i=0;i<4;i++) base.forEach(c => deck.push(JSON.parse(JSON.stringify(c))));
  shuffle(deck);
  updateDeckCount();
}

// --- Board init & render ---
function initBoard(){
  boardEl.innerHTML = '';
  for(let i=0;i<CELLS;i++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.idx = i;
    cell.addEventListener('click', ()=>onCellClick(i));
    cell.addEventListener('dragover', (e)=>e.preventDefault());
    cell.addEventListener('drop', (e)=>onDrop(e,i));
    boardEl.appendChild(cell);
  }
}
function updateDeckCount(){ document.getElementById('deckCount').textContent = deck.length; }
function render(){
  // render cells
  for(let i=0;i<CELLS;i++){
    const el = boardEl.children[i];
    el.innerHTML = '';
    el.classList.toggle('occupied', !!playerUnits[i] || !!enemyUnits[i]);
    const u = playerUnits[i] || enemyUnits[i];
    if(u){
      const unit = document.createElement('div');
      unit.className = 'unit';
      unit.innerHTML = `<div class="name">${u.icon} ${u.name}</div><div class="stats">${u.atk} / ${u.hp}</div>`;
      el.appendChild(unit);
      if(enemyUnits[i]){
        const badge = document.createElement('div');
        badge.style.position='absolute';
        badge.style.left='6px';
        badge.style.top='6px';
        badge.style.fontSize='11px';
        badge.textContent='‡∏®‡∏±‡∏ï‡∏£‡∏π';
        el.appendChild(badge);
      }
    }
  }
  // hand
  playerHandEl.innerHTML = '';
  playerHand.forEach((c,idx) => {
    const cardEl = document.createElement('div');
    cardEl.className = 'card';
    if(c.cost > mana) cardEl.classList.add('disabled');
    cardEl.draggable = true;
    cardEl.dataset.idx = idx;
    cardEl.innerHTML = `<div class="art">${c.icon}</div><div style="font-size:13px">${c.name}</div><div style="font-weight:800">${c.atk}/${c.hp} ‚Ä¢ ${c.cost}</div>`;
    cardEl.addEventListener('dragstart', (e)=>{ dragIndex = idx; e.dataTransfer.setData('text/plain', idx); });
    cardEl.addEventListener('click', ()=>selectHand(idx));
    cardEl.addEventListener('mouseenter', (e)=>showTooltip(e, tooltipText(c)));
    cardEl.addEventListener('mousemove', (e)=>moveTooltip(e));
    cardEl.addEventListener('mouseleave', hideTooltip);
    playerHandEl.appendChild(cardEl);
  });
  // enemy zone
  enemyZoneEl.innerHTML = '';
  enemyHand.forEach(c => {
    const el = document.createElement('div');
    el.className = 'card';
    el.style.width='84px';
    el.style.height='110px';
    el.style.marginRight='6px';
    el.innerHTML = `<div style="font-size:18px">${c.icon}</div><div style="margin-top:6px">${c.name}</div><div style="font-weight:800">${c.atk}/${c.hp}</div>`;
    enemyZoneEl.appendChild(el);
  });
  // HUD
  document.getElementById('playerHP').textContent = playerHP;
  document.getElementById('enemyHP').textContent = enemyHP;
  document.getElementById('playerFill').style.width = Math.max(0,(playerHP/36)*100) + '%';
  document.getElementById('enemyFill').style.width = Math.max(0,(enemyHP/28)*100) + '%';
  document.getElementById('mana').textContent = mana;
  document.getElementById('maxMana').textContent = maxMana;
  updateDeckCount();
}

// --- Tooltip ---
function tooltipText(c){
  let t = `${c.name}\nATK ${c.atk} / HP ${c.hp}\nCost ${c.cost}`;
  if(c.effect) t += `\n${c.effect.type} ${c.effect.value || ''}`;
  return t;
}

// --- Card placement & play ---
function selectHand(idx){
  if(playerHand[idx].cost > mana){ flash('Mana ‡πÑ‡∏°‡πà‡∏û‡∏≠', 'danger'); return; }
  selectedHandIndex = idx;
  addLog('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î: ' + playerHand[idx].name, 'player');
}
function onDrop(e, cellIdx){
  e.preventDefault();
  const handIdx = Number(e.dataTransfer.getData('text/plain'));
  placeCard(handIdx, cellIdx);
}
function onCellClick(idx){
  if(selectedHandIndex !== null){
    placeCard(selectedHandIndex, idx);
    selectedHandIndex = null;
    return;
  }
  const u = playerUnits[idx] || enemyUnits[idx];
  if(u) showModal(u.name, `ATK ${u.atk} ‚Ä¢ HP ${u.hp}`);
}
function placeCard(handIdx, cellIdx){
  const card = playerHand[handIdx];
  if(!card) return;
  const row = Math.floor(cellIdx / COLS);
  if(row < Math.ceil(ROWS/2)){ flash('‡∏ß‡∏≤‡∏á‡πÑ‡∏î‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ù‡∏±‡πà‡∏á‡∏•‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì'); return; }
  if(playerUnits[cellIdx] || enemyUnits[cellIdx]){ flash('‡∏ä‡πà‡∏≠‡∏á‡πÑ‡∏°‡πà‡∏ß‡πà‡∏≤‡∏á'); return; }
  if(card.cost > mana){ flash('Mana ‡πÑ‡∏°‡πà‡∏û‡∏≠','danger'); return; }
  mana -= card.cost;
  playerUnits[cellIdx] = card;
  playerHand.splice(handIdx,1);
  addLog('‡∏Ñ‡∏∏‡∏ì‡∏ß‡∏≤‡∏á ' + card.name, 'player');
  playTone('attack');
  render();
}

// --- Draw / Deck ---
function drawToPlayer(n=1){
  for(let i=0;i<n;i++){
    if(deck.length===0) break;
    if(playerHand.length >= 7) break;
    playerHand.push(deck.pop());
  }
  playTone('draw');
  render();
}
function drawToAI(n=1){
  for(let i=0;i<n;i++){
    if(deck.length===0) break;
    if(enemyHand.length >= 7) break;
    enemyHand.push(deck.pop());
  }
  render();
}

// --- Combat resolution ---
function endTurn(){
  addLog('‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô ‚Äî ‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÇ‡∏à‡∏°‡∏ï‡∏µ', 'player');
  resolveAttacks('player');
  setTimeout(()=>aiTurnRoutine(), 600);
}
function resolveAttacks(owner){
  if(owner === 'player'){
    for(let i=0;i<CELLS;i++){
      const u = playerUnits[i];
      if(!u) continue;
      if(u.sleep && u.sleep > 0){ u.sleep--; continue; }
      const targetIdx = findTarget(i, 'enemy');
      if(targetIdx !== null){
        attackUnit(i, targetIdx, 'player');
      } else {
        enemyHP -= Math.max(0, u.atk);
        addLog(`${u.name} ‡∏ï‡∏µ‡∏´‡∏ô‡πâ‡∏≤ -${u.atk}`, 'player');
        playTone('attack');
      }
    }
  } else {
    for(let i=0;i<CELLS;i++){
      const u = enemyUnits[i];
      if(!u) continue;
      if(u.sleep && u.sleep > 0){ u.sleep--; continue; }
      const targetIdx = findTarget(i, 'player');
      if(targetIdx !== null){
        attackUnitEnemy(i, targetIdx);
      } else {
        playerHP -= Math.max(0, u.atk);
        addLog(`‡∏®‡∏±‡∏ï‡∏£‡∏π ${u.name} ‡∏ï‡∏µ‡∏Ñ‡∏∏‡∏ì -${u.atk}`, 'enemy');
        playTone('attack');
      }
    }
  }
  applyEndOfRound();
  render();
  checkGameEnd();
}
function findTarget(idx, targetType){
  const col = idx % COLS;
  const row = Math.floor(idx / COLS);
  if(targetType === 'enemy'){
    for(let r = row-1; r >= 0; r--){
      const i = r*COLS + col;
      if(enemyUnits[i]) return i;
    }
  } else {
    for(let r = row+1; r < ROWS; r++){
      const i = r*COLS + col;
      if(playerUnits[i]) return i;
    }
  }
  return null;
}
function attackUnit(fromIdx, toIdx, owner){
  const attacker = playerUnits[fromIdx];
  const defender = enemyUnits[toIdx];
  if(!attacker || !defender) return;
  defender.hp -= attacker.atk;
  addLog(`${attacker.name} ‡∏ï‡∏µ ${defender.name} -${attacker.atk}`, 'player');
  animateAttack(fromIdx, toIdx);
  playTone('attack');
  if(attacker.effect && attacker.effect.type === 'double'){
    if(enemyUnits[toIdx] && enemyUnits[toIdx].hp > 0){
      enemyUnits[toIdx].hp -= attacker.atk;
      addLog(`${attacker.name} ‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡∏ã‡πâ‡∏≥ ${defender.name} -${attacker.atk}`, 'player');
    }
  }
}
function attackUnitEnemy(fromIdx, toIdx){
  const attacker = enemyUnits[fromIdx];
  const defender = playerUnits[toIdx];
  if(!attacker || !defender) return;
  defender.hp -= attacker.atk;
  addLog(`‡∏®‡∏±‡∏ï‡∏£‡∏π ${attacker.name} ‡∏ï‡∏µ ${defender.name} -${attacker.atk}`, 'enemy');
  animateAttack(fromIdx, toIdx);
  playTone('attack');
}

// --- End round effects ---
function applyEndOfRound(){
  // poison ticks (if any) and cleanup dead units
  for(let i=0;i<CELLS;i++){
    if(playerUnits[i] && playerUnits[i].poison){ playerUnits[i].hp -= playerUnits[i].poison; addLog(`${playerUnits[i].name} ‡∏ñ‡∏π‡∏Å‡∏û‡∏¥‡∏© -${playerUnits[i].poison}`, 'player'); }
    if(enemyUnits[i] && enemyUnits[i].poison){ enemyUnits[i].hp -= enemyUnits[i].poison; addLog(`${enemyUnits[i].name} ‡∏ñ‡∏π‡∏Å‡∏û‡∏¥‡∏© -${enemyUnits[i].poison}`, 'enemy'); }
  }
  for(let i=CELLS-1;i>=0;i--){
    if(playerUnits[i] && playerUnits[i].hp <= 0){ addLog(`${playerUnits[i].name} ‡∏ï‡∏≤‡∏¢`, 'player'); playerUnits[i] = null; }
    if(enemyUnits[i] && enemyUnits[i].hp <= 0){ addLog(`‡∏®‡∏±‡∏ï‡∏£‡∏π ${enemyUnits[i].name} ‡∏ï‡∏≤‡∏¢`, 'enemy'); enemyUnits[i] = null; }
  }
}

// --- Visual attack animation ---
function animateAttack(a,b){
  const from = boardEl.children[a].getBoundingClientRect();
  const to = boardEl.children[b].getBoundingClientRect();
  const dot = document.createElement('div');
  dot.style.position = 'fixed';
  dot.style.width = '12px';
  dot.style.height = '12px';
  dot.style.borderRadius = '50%';
  dot.style.background = 'radial-gradient(circle,#ffd166,#ff7b7b)';
  dot.style.left = (from.left + from.width/2) + 'px';
  dot.style.top = (from.top + from.height/2) + 'px';
  dot.style.zIndex = 9999;
  document.body.appendChild(dot);
  const dx = (to.left + to.width/2) - (from.left + from.width/2);
  const dy = (to.top + to.height/2) - (from.top + from.height/2);
  dot.animate([{ transform: 'translate(0,0)' }, { transform: `translate(${dx}px,${dy}px)` }], { duration: 420, easing: 'ease-out' }).onfinish = ()=>dot.remove();
}

// --- AI (easy) ---
function aiTurnRoutine(){
  addLog('AI ‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô', 'enemy');
  // increase AI mana slowly
  aiMaxMana = Math.min(10, (aiMaxMana || 4) + 1);
  aiMana = Math.min(aiMaxMana, (aiMana || 0) + 1);
  // AI draw limited 1
  drawToAI(1);
  // AI plays up to 1 card (choose affordable)
  let played = 0;
  for(let i = enemyHand.length - 1; i >= 0 && played < 1; i--){
    const c = enemyHand[i];
    if(c.cost <= aiMana){
      // prefer heal if low HP
      if(enemyHP <= 12 && c.effect && c.effect.type === 'heal'){
        playAICard(i);
        played++;
        break;
      }
      // otherwise play first affordable
      playAICard(i);
      played++;
      break;
    }
  }
  // AI then attacks
  resolveAttacks('enemy');
  // start player turn after small delay
  setTimeout(()=>startPlayerTurn(), 600);
}
function playAICard(handIdx){
  const c = enemyHand[handIdx];
  if(!c) return;
  if(c.cost > aiMana) return;
  const spot = findEmptySpot('enemy');
  if(spot === null) return;
  aiMana -= c.cost;
  enemyUnits[spot] = c;
  c.sleep = 1;
  enemyHand.splice(handIdx, 1);
  addLog('AI ‡∏ß‡∏≤‡∏á ' + c.name, 'enemy');
}

// --- Helpers ---
function findEmptySpot(side){
  const cand = [];
  for(let i=0;i<CELLS;i++){
    const r = Math.floor(i / COLS);
    if(side === 'enemy' && r < Math.floor(ROWS/2) && !enemyUnits[i] && !playerUnits[i]) cand.push(i);
    if(side === 'player' && r >= Math.ceil(ROWS/2) && !playerUnits[i] && !enemyUnits[i]) cand.push(i);
  }
  if(cand.length === 0) return null;
  return cand[Math.floor(Math.random() * cand.length)];
}

// --- Start / Turn management ---
function startPlayerTurn(){
  maxMana = Math.min(14, maxMana + 2);
  mana = maxMana;
  // draw 1 card
  drawToPlayer(1);
  addLog('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‚Äî ‡πÑ‡∏î‡πâ Mana ‡πÅ‡∏•‡∏∞‡∏à‡∏±‡πà‡∏ß 1 ‡πÉ‡∏ö', 'player');
  render();
}
function checkGameEnd(){
  if(playerHP <= 0){
    addLog('‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏û‡πâ', 'enemy');
    stats.losses++; stats.games++; saveStats();
    showModal('‡πÅ‡∏û‡πâ', 'HP ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏´‡∏•‡∏∑‡∏≠ 0 ‚Äî ‡πÄ‡∏Å‡∏°‡∏à‡∏∞‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï'); setTimeout(()=>startGame(), 1100);
  } else if(enemyHP <= 0){
    addLog('‡∏Ñ‡∏∏‡∏ì‡∏ä‡∏ô‡∏∞', 'player');
    stats.wins++; stats.games++; saveStats();
    showModal('‡∏ä‡∏ô‡∏∞', '‡∏Ñ‡∏∏‡∏ì‡∏ó‡∏≥‡∏•‡∏≤‡∏¢‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÑ‡∏î‡πâ ‚Äî ‡∏¢‡∏¥‡∏ô‡∏î‡∏µ‡∏î‡πâ‡∏ß‡∏¢'); setTimeout(()=>startGame(), 1100);
  }
}

// --- Persistence ---
function loadStats(){ try{ const s = localStorage.getItem('cardduel_stats'); if(s) stats = JSON.parse(s); }catch(e){} }
function saveStats(){ try{ localStorage.setItem('cardduel_stats', JSON.stringify(stats)); }catch(e){} }

// --- Small UI helpers ---
function flash(text, type='info'){ showModal(type==='danger'?'‡πÅ‡∏à‡πâ‡∏á‡πÄ‡∏ï‡∏∑‡∏≠‡∏ô':'‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°', text); setTimeout(hideModal, 900); }
function addLog(text, who='info'){ addLogDOM(text, who); }
function addLogDOM(t, who='info'){ const d = document.createElement('div'); d.innerHTML = (who==='player'?`<span style="color:#6ee7b7">`:`<span style="color:#ff8b8b">`) + t + '</span>'; logEl.prepend(d); }

// --- Deck & start ---
function placeInitialEnemies(){
  for(let i=0;i<3;i++){
    if(deck.length === 0) break;
    const c = deck.pop();
    const spot = findEmptySpot('enemy');
    if(spot !== null){ enemyUnits[spot] = c; c.sleep = 1; }
  }
}
function startGame(){
  buildDeck();
  playerHand = []; enemyHand = [];
  playerUnits = Array(CELLS).fill(null); enemyUnits = Array(CELLS).fill(null);
  playerHP = 36; enemyHP = 28;
  mana = 6; maxMana = 6; aiMana = 4; aiMaxMana = 4;
  stats.games = stats.games || 0;
  drawToPlayer(4); placeInitialEnemies();
  render();
  addLog('‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°‡πÉ‡∏´‡∏°‡πà', 'player');
}
function drawToPlayer(n=1){
  for(let i=0;i<n;i++){
    if(deck.length === 0) break;
    if(playerHand.length >= 7) break;
    playerHand.push(deck.pop());
  }
  playTone('draw');
  render();
}
function drawToAI(n=1){
  for(let i=0;i<n;i++){
    if(deck.length === 0) break;
    if(enemyHand.length >= 7) break;
    enemyHand.push(deck.pop());
  }
  render();
}

// --- Play from player hand (click) ---
function playFromHand(idx){
  if(idx < 0 || idx >= playerHand.length) return;
  const c = playerHand[idx];
  if(c.cost > mana){ flash('Mana ‡πÑ‡∏°‡πà‡∏û‡∏≠','danger'); return; }
  const spot = findEmptySpot('player');
  if(spot === null){ flash('‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏á‡∏ö‡∏ô‡∏Å‡∏£‡∏∞‡∏î‡∏≤‡∏ô'); return; }
  mana -= c.cost;
  playerUnits[spot] = c;
  c.sleep = 1;
  playerHand.splice(idx,1);
  addLog('‡∏Ñ‡∏∏‡∏ì‡∏ß‡∏≤‡∏á ' + c.name, 'player');
  playTone('attack');
  render();
}

// --- AI helpers (play card) already above as playAICard -- keep) ---

// Event bindings
document.getElementById('btnNew').addEventListener('click', ()=>startGame());
document.getElementById('btnDraw').addEventListener('click', ()=>{ drawToPlayer(1); });
document.getElementById('btnEnd').addEventListener('click', ()=>{ endTurn(); });
document.getElementById('btnHint').addEventListener('click', ()=>showModal('‡∏ß‡∏¥‡∏ò‡∏µ‡πÄ‡∏•‡πà‡∏ô', `<ul style="text-align:left"><li>‡∏•‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡∏´‡∏£‡∏∑‡∏≠‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πå‡∏î‡πÅ‡∏•‡πâ‡∏ß‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ä‡πà‡∏≠‡∏á‡∏ù‡∏±‡πà‡∏á‡∏•‡πà‡∏≤‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏≤‡∏á</li><li>Mana ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏ï‡∏≠‡∏ô‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô (+2) ‡πÅ‡∏•‡∏∞‡∏°‡∏µ‡πÄ‡∏û‡∏î‡∏≤‡∏ô</li><li>AI ‡∏à‡∏±‡πà‡∏ß 1/‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô ‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πà‡∏ô 1 ‡πÉ‡∏ö/‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô (‡∏á‡πà‡∏≤‡∏¢)</li><li>‡∏¢‡∏π‡∏ô‡∏¥‡∏ï‡∏à‡∏∞‡πÇ‡∏à‡∏°‡∏ï‡∏µ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Ñ‡∏∏‡∏ì‡∏à‡∏ö‡πÄ‡∏ó‡∏¥‡∏£‡πå‡∏ô</li></ul>`));

// click on hand to play (delegation)
playerHandEl.addEventListener('click', (e)=>{
  const cardEl = e.target.closest('.card');
  if(!cardEl) return;
  const idx = Number(cardEl.dataset.idx);
  playFromHand(idx);
});

// drag end cleanup
window.addEventListener('dragend', ()=>{ dragIndex = null; });

// init
initBoard();
loadStats();
startGame();

</script>
</body>
</html>
